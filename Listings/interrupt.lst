C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/08/2024 23:47:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Output\interrupt.obj
COMPILER INVOKED BY: D:\APP\Keil_STM32\C51\BIN\C51.EXE BSP\Src\interrupt.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\BSP\I
                    -nc;.\Core\Inc;.\Drivers;.\Emembed\Inc;.\Emembed\Inc;.\Middlewares;.\SYSTEM) DEBUG OBJECTEXTEND PRINT(.\Listings\interrup
                    -t.lst) OBJECT(.\Output\interrupt.obj)

line level    source

   1           #include "interrupt.h"
   2          
   3          static bit zero_flag = 0;       //å¤–éƒ¨ä¸­æ–­ï¼ˆè¿‡é›¶æ£€æµ‹ï¼‰et0å“åº”flag å“åº”èµ‹å€¼ä¸º1
   4          
   5          bit busy_flag1    = 0;          //ä¸²å£1ç­‰å¾…æ¥æ”¶æ ‡å¿—ä½
   6          bit busy_flag4    = 0;          //ä¸²å£4ç­‰å¾…æ¥æ”¶æ ‡å¿—ä½
   7          
   8          bit heating_flag1 = 1;
   9          bit heating_flag2 = 1;
  10          bit heating_flag3 = 1;
  11          bit heating_flag4 = 1;
  12          
  13          uint8_t TX1_buf[128];
  14          uint8_t TX1_send_bytelength; 
  15          uint8_t TX1_send_cnt;  
  16          
  17          bit RX1_rev_end_flag = 0;             //æ•°æ®åŒ…å‘é€å®Œæ¯•æ ‡å¿—
  18          uint8_t  RX1_buf[128];    //SBUF RIç¼“å†²åŒº
  19          uint16_t RX1_rev_timeout;    //æ¥æ”¶è¶…æ—¶
  20          uint8_t  RX1_rev_bytenum = 0;     //æ¥æ”¶è®¡æ•°
  21          
  22          uint16_t phase_shift_time = 65520;
  23          
  24          void Uart1_ISR() interrupt 4 
  25          {   
  26   1          if( TI == 1 )
  27   1          {
  28   2              TI = 0;
  29   2              busy_flag1 = 0;
  30   2              if(TX1_send_bytelength != 0)
  31   2              {
  32   3                  SBUF = TX1_buf[TX1_send_cnt++];
  33   3                  TX1_send_bytelength--;
  34   3              }
  35   2          }
  36   1          
  37   1          if( RI == 1 )
  38   1          {
  39   2              RI = 0;
  40   2              if(!RX1_rev_end_flag)
  41   2              {
  42   3                  if(RX1_rev_bytenum > 128)
  43   3                  {
  44   4                      RX1_rev_bytenum = 0;
  45   4                  }
  46   3                  RX1_buf[RX1_rev_bytenum] = SBUF;
  47   3                  RX1_rev_bytenum++;
  48   3              }
  49   2              RX1_rev_timeout = 150;
  50   2          }
  51   1      }
  52          
  53          void Tim0_ISR( void ) interrupt 1   //1ms
C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/08/2024 23:47:19 PAGE 2   

  54          {
  55   1          if (RX1_rev_timeout != 0)  //uart1ä¸­è®¾å®šä¸º50 å¼€å§‹æ‰§è¡Œ
  56   1          {
  57   2              RX1_rev_timeout--;
  58   2              if( RX1_rev_timeout == 0 )  //è¶…æ—¶
  59   2              {
  60   3                  if( RX1_rev_bytenum > 0 )  //æ¥æ”¶çš„æ•°æ®åŒ…ä¸ä¸ºç©º
  61   3                  {
  62   4                      RX1_rev_end_flag = 1;   //æ¥æ”¶å®Œæ¯•æ ‡å¿—ä½äº®èµ·
  63   4                      RX1_rev_bytenum = 0;  //åˆå§‹åŒ–æ¥æ”¶ç¼“å†²åŒº
  64   4                  }
  65   3              }
  66   2          } 
  67   1      }
  68          
  69          void Uart4_ISR() interrupt 18 using 1
  70          {   
  71   1          if(S4CON & S4RI)  
  72   1          {
  73   2              S4CON &= ~S4RI;
  74   2          }
  75   1          
  76   1          if(S4CON & S4TI)            
  77   1          {  
  78   2              S4CON &= ~S4TI;  
  79   2              busy_flag4 = 0;
  80   2          }
  81   1      }
  82          
  83          void ET0_ISR(void) interrupt 0 
  84          {
  85   1          heating_channel1 = heating_channel2 = heating_channel3 = heating_channel4 = 1;    
  86   1          /*      å»¶æ—¶ç§»ç›¸        */
  87   1          TL1 = phase_shift_time;                             //è®¾ç½®å®šæ—¶åˆå§‹å€¼
  88   1              TH1 = phase_shift_time>>8;                              //è®¾ç½®å®šæ—¶åˆå§‹å€¼
  89   1      
  90   1          zero_flag = 1;
  91   1          
  92   1          TR1 = 1;                            //å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶      
  93   1          ET1 = 1; 
  94   1      }
  95          
  96          void Tim1_ISR(void) interrupt 3 
  97          {
  98   1      
  99   1          if( zero_flag == 1 )
 100   1          {
 101   2              heating_channel1 = ~heating_flag1;
 102   2              heating_channel2 = ~heating_flag2;
 103   2              heating_channel3 = ~heating_flag3;
 104   2              heating_channel4 = ~heating_flag4;
 105   2              /*      å‘é€ä¸€ä¸ª10usçš„è„‰å†²      */
 106   2              zero_flag = 0;
 107   2      
 108   2              TL1 = 0xF7;                             //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 109   2              TH1 = 0xFF;                             //è®¾ç½®å®šæ—¶åˆå§‹å€¼
 110   2          }
 111   1          else
 112   1          {
 113   2              heating_channel1 = heating_channel2 = heating_channel3 = heating_channel4 = 1;     //1-0-1çš„è„‰å†
             -² 2us
 114   2              TR1 = 0;                                   
C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/08/2024 23:47:19 PAGE 3   

 115   2              ET1 = 0;                  //å®šæ—¶å™¨å…³é—­è®¡æ—¶   
 116   2          }
 117   1      }
 118          
 119          
 120          
 121          void Tim3_ISR(void) interrupt 19 
 122          {
 123   1          
 124   1      }
 125          
 126          
 127          
 128          // void Uart4_ISP() interrupt 18 using 1
 129          // {   
 130          //     if(S4CON & S4RI)   
 131          //     {
 132          //         S4CON &= ~S4RI;
 133          //         flag = 1;
 134          //     }
 135              
 136          //     if(S4CON & S4TI)            
 137          //     {  
 138          //         S4CON &= ~S4TI;  
 139          //         busy = 0;
 140          //     }
 141          // }
 142          
 143          // void sendbyte(uint8_t dat)
 144          // {
 145          //         while(busy);
 146          //         busy = 1;
 147          //         S4BUF = dat;
 148          // }
 149          
 150          // void sendstring(uint8_t *sendstr)
 151          // {
 152          //     while(*sendstr)
 153          //     {
 154          //         sendbyte(*sendstr++);
 155          //     }
 156          // }
 157          
 158          // void rs485()
 159          // {
 160          //     if(S4BUF == 0X85 && flag == 1)   
 161          //     {    
 162          //         DR4 = 1;
 163          //         delay_ms(5);    //å»¶æ—¶1msï¼Œä¸å¯çœå»
 164                  
 165          //         sendstring("madezhenfan \r\n");
 166          //         delay_ms(5);   //å»¶æ—¶æ ¹æ®å†…å®¹è°ƒï¼Œå‘é€å†…å®¹è¶Šå¤šï¼Œå»¶æ—¶è¶Šä¹…
 167                  
 168          //         DR4 = 0;
 169          //         delay_ms(5);    //å»¶æ—¶1msï¼Œä¸å¯çœå»
 170                      
 171          //         flag = 0;
 172          //     }
 173          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.7.0   INTERRUPT                                                         12/08/2024 23:47:19 PAGE 4   

   CODE SIZE        =    296    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    263    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
